# -*- coding: utf-8 -*-

"""
/***************************************************************************
 VROOM_for_QGIS
                                 A QGIS plugin
 This plugin makes it possible to send data from a QGIS layer to VROOM.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-04-21
        copyright            : (C) 2025 by Suddber
        email                : suddb@posteo.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Suddber'
__date__ = '2025-04-21'
__copyright__ = '(C) 2025 by Suddber'
__revision__ = '$Format:%H$'

import requests
from qgis import processing
from qgis.PyQt.QtCore import QCoreApplication, QDateTime, QVariant
from qgis.core import (QgsProcessing,
                       QgsProcessingAlgorithm,
                       QgsProcessingException,
                       QgsProcessingParameterBoolean,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterField,
                       QgsProcessingParameterString,
                       QgsField,
                       QgsFields,
                       QgsFeature,
                       QgsGeometry,
                       QgsCoordinateReferenceSystem,
                       QgsWkbTypes,
                       QgsPoint,
                       QgsPointXY
                       )


class VROOM_for_QGISAlgorithm(QgsProcessingAlgorithm):

    OUT_LINES =  'OUT_LINES'
    OUT_POINTS = 'OUT_POINS'
    OUT_SUMMARY= 'OUT_SUMMARY'
    
    IN_ORS_BOOL = 'IN_ORS_BOOL'
    IN_ORS_EXT = 'IN_ORS_EXT'
    IN_AUTH_KEY = 'IN_AUTH_KEY'
    IN_VEHICLE_TYPE = 'IN_VEHICLE_TYPE'
    IN_OSRM_PORT = 'IN_OSRM_PORT'

    IN_VEHICLE_LAYER = 'IN_VEHICLE_LAYER'
    IN_VEHICLE_START_BOOL = 'IN_VEHICLE_START_BOOL'
    IN_VEHICLE_END_BOOL = 'IN_VEHICLE_END_BOOL'
    IN_VEHICLE_DESCRIPTION_FIELD = 'IN_VEHICLE_DESCRIPTION_FIELD'
    IN_VEHICLE_CAPACITY_FIELD = 'IN_VEHICLE_CAPACITY_FIELD'
    IN_VEHICLE_SKILL_FIELD = 'IN_VEHICLE_SKILL_FIELD'
    IN_VEHICLE_TIME_WINDOW = 'IN_VEHICLE_TIME_WINDOW'
    IN_VEHICLE_SPEED_FACTOR_FIELD = 'IN_VEHICLE_SPEED_FACTOR_FIELD'
    IN_VEHICLE_MAX_TASKS_FIELD = 'IN_VEHICLE_MAX_TASKS_FIELD'
    IN_VEHICLE_MAX_TRAVEL_TIME = 'IN_VEHICLE_MAX_TRAVEL_TIME'
    IN_VEHICLE_MAX_DISTANCE = 'IN_VEHICLE_MAX_DISTANCE'

    IN_BREAK = 'IN_BREAK'
    
    IN_PICKUP_LAYER = 'IN_PICKUP_LAYER'
    IN_START_FIELD = 'IN_START_FIELD'
    IN_AMOUNT_FIELD = 'IN_AMOUNT_FIELD'
    IN_SKILL_FIELD = 'IN_SKILL_FIELD'
    IN_PRIORITY_FIELD = 'IN_PRIORITY_FIELD'
    IN_PICKUP_DESCRIPTION = 'IN_PICKUP_DESCRIPTION'
    IN_PICKUP_SETUP_DURATION_FIELD = 'IN_PICKUP_SETUP_TIME_FIELD'
    IN_PICKUP_SERVICE_DURATION_FIELD = 'IN_PICKUP_SERVICE_DURATION_FIELD'
    IN_PICKUP_TIME_WINDOWS = 'IN_PICKUP_TIME_WINDOW'
    
    IN_DELIVERY_LAYER = 'IN_DELIVERY_LAYER'
    IN_END_FIELD = 'IN_END_FIELD'
    IN_DELIVERY_DESCRIPTION = 'IN_DELIVERY_DESCRIPTION'
    IN_DELIVERY_SETUP_DURATION_FIELD = 'IN_DELIVERY_SETUP_DURATION_FIELD'
    IN_DELIVERY_SERVICE_DURATION_FIELD = 'IN_DELIVERY_SERVICE_DURATION_FIELD'
    IN_DELIVERY_TIME_WINDOWS = 'IN_DELIVERY_TIME_WINDOWS'

    def initAlgorithm(self, config):

        # Output parameters

        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUT_LINES,
                self.tr('Output layer with routes')
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUT_POINTS,
                self.tr('Output layer with steps')
            )
        )
        
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUT_SUMMARY,
                self.tr('Output layer with summary')
            )
        )
        
        # Input parameters

        self.addParameter(
            QgsProcessingParameterBoolean(
                self.IN_ORS_BOOL,
                self.tr('Use Openrouteservice (ORS) for routes'),
                defaultValue=False
            )
        )

        self.addParameter(
            QgsProcessingParameterBoolean(
                self.IN_ORS_EXT,
                self.tr('Use ORS optimization API'),
                defaultValue=False
            )
        )

        self.addParameter(
            QgsProcessingParameterString(
                self.IN_AUTH_KEY,
                self.tr('Key for ORS optimization API'),
                optional=True
            )
        )

        # travel modes for Openrouteservice

        PREFERENCES = ['driving-car',
                       'driving-hgv',
                       "cycling-regular",
                       "cycling-road",
                       "cycling-safe",
                       "cycling-mountain",
                       "cycling-electric",
                       "foot-walking",
                       "foot-hiking",
                       "wheelchair"]

        self.addParameter(
            QgsProcessingParameterEnum(
                self.IN_VEHICLE_TYPE,
                "Travel mode for ORS",
                PREFERENCES,
                defaultValue=PREFERENCES[0],
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterString(
                self.IN_OSRM_PORT,
                self.tr('Port number of running Vroom Express'),
                defaultValue='3000'
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.IN_VEHICLE_LAYER,
                self.tr('Layer with vehicle points'),
                [QgsProcessing.TypeVectorPoint]
            )
        )

        self.addParameter(
            QgsProcessingParameterBoolean(
                self.IN_VEHICLE_START_BOOL,
                self.tr('Start from Depot'),
                defaultValue=True
            )
        )

        self.addParameter(
            QgsProcessingParameterBoolean(
                self.IN_VEHICLE_END_BOOL,
                self.tr('Return to Depot'),
                defaultValue=True
            )
        )
 
        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_VEHICLE_CAPACITY_FIELD,
                description="Field for capacity array of vehicles",
                parentLayerParameterName=self.IN_VEHICLE_LAYER,
                type=QgsProcessingParameterField.String,
                optional=False
            )
        )

        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_VEHICLE_DESCRIPTION_FIELD,
                description="Field for description of vehicles",
                parentLayerParameterName=self.IN_VEHICLE_LAYER,
                type=QgsProcessingParameterField.Any,
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_VEHICLE_SKILL_FIELD,
                description="Field for skill array of vehicles",
                parentLayerParameterName=self.IN_VEHICLE_LAYER,
                type=QgsProcessingParameterField.String,
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_VEHICLE_TIME_WINDOW,
                description="Field for time window arrays of vehicles (in seconds)",
                parentLayerParameterName=self.IN_VEHICLE_LAYER,
                type=QgsProcessingParameterField.String,
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_VEHICLE_SPEED_FACTOR_FIELD,
                description="speed factor in the range (0, 5] (default 1), precision is two decimal points",
                parentLayerParameterName=self.IN_VEHICLE_LAYER,
                type=QgsProcessingParameterField.Numeric,
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_VEHICLE_MAX_TASKS_FIELD,
                description="Field for maximum number of tasks of vehicle",
                parentLayerParameterName=self.IN_VEHICLE_LAYER,
                type=QgsProcessingParameterField.Numeric,
                optional=True
            )
        )


        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_VEHICLE_MAX_TRAVEL_TIME,
                description="Field for maximum travel time (in seconds)",
                parentLayerParameterName=self.IN_VEHICLE_LAYER,
                type=QgsProcessingParameterField.Numeric,
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_VEHICLE_MAX_DISTANCE,
                description="Field for maximum distance in meters",
                parentLayerParameterName=self.IN_VEHICLE_LAYER,
                type=QgsProcessingParameterField.Numeric,
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_BREAK,
                description="Field for array of break objects",
                parentLayerParameterName=self.IN_VEHICLE_LAYER,
                type=QgsProcessingParameterField.String,
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.IN_PICKUP_LAYER,
                self.tr('Layer with pickup points'),
                [QgsProcessing.TypeVectorPoint]
            )
        )

        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_START_FIELD,
                description="Start ID Field",
                parentLayerParameterName=self.IN_PICKUP_LAYER,
            )
        )
        
        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_AMOUNT_FIELD,
                description="Field for amount array",
                parentLayerParameterName=self.IN_PICKUP_LAYER,
                type=QgsProcessingParameterField.String,
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_SKILL_FIELD,
                description="Field for skills array",
                parentLayerParameterName=self.IN_PICKUP_LAYER,
                type=QgsProcessingParameterField.String,
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_PRIORITY_FIELD,
                description="Field for priority of shipment (number from 0 to 100)",
                parentLayerParameterName=self.IN_PICKUP_LAYER,
                type=QgsProcessingParameterField.Numeric,
                optional=True
            )
        )
        
        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_PICKUP_DESCRIPTION,
                description="Field for pickup description",
                parentLayerParameterName=self.IN_PICKUP_LAYER,
                type=QgsProcessingParameterField.Any,
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_PICKUP_SETUP_DURATION_FIELD,
                description="Field for setup duration of pickup (in seconds)",
                parentLayerParameterName=self.IN_PICKUP_LAYER,
                type=QgsProcessingParameterField.Numeric,
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_PICKUP_SERVICE_DURATION_FIELD,
                description="Field for service duration of pickup (in seconds)",
                parentLayerParameterName=self.IN_PICKUP_LAYER,
                type=QgsProcessingParameterField.Numeric,
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_PICKUP_TIME_WINDOWS,
                description="Field for time windows array of pickup (in seconds)",
                parentLayerParameterName=self.IN_PICKUP_LAYER,
                type=QgsProcessingParameterField.String,
                optional=True
            )
        )
        
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.IN_DELIVERY_LAYER,
                self.tr('Layer with delivery points'),
                [QgsProcessing.TypeVectorPoint]
            )
        )

        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_END_FIELD,
                description="End ID Field",
                parentLayerParameterName=self.IN_DELIVERY_LAYER,
            )
        )

        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_DELIVERY_DESCRIPTION,
                description="Field description of delivery",
                parentLayerParameterName=self.IN_DELIVERY_LAYER,
                type=QgsProcessingParameterField.Any,
                optional=True
            )
        )
        
        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_DELIVERY_SETUP_DURATION_FIELD,
                description="Field for setup duration of delivery (in seconds)",
                parentLayerParameterName=self.IN_DELIVERY_LAYER,
                type=QgsProcessingParameterField.Numeric,
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_DELIVERY_SERVICE_DURATION_FIELD,
                description="Field for service duration of delivery (in seconds)",
                parentLayerParameterName=self.IN_DELIVERY_LAYER,
                type=QgsProcessingParameterField.Numeric,
                optional=True
            )
        )

        self.addParameter(
            QgsProcessingParameterField(
                name=self.IN_DELIVERY_TIME_WINDOWS,
                description="Field for time windows array of delivery (in seconds)",
                parentLayerParameterName=self.IN_DELIVERY_LAYER,
                type=QgsProcessingParameterField.String,
                optional=True
            )
        )

    def processAlgorithm(self, parameters, context, feedback):

        # Input parameters to variables
   
        ors_bool = self.parameterAsBool(parameters, self.IN_ORS_BOOL, context)
        ors_ext = self.parameterAsBool(parameters, self.IN_ORS_EXT, context)
        key = self.parameterAsString(parameters, self.IN_AUTH_KEY, context)
        ors_preference_nr = self.parameterAsString(parameters, self.IN_VEHICLE_TYPE, context)
        port = self.parameterAsString(parameters, self.IN_OSRM_PORT, context)

        vehicle_layer = self.parameterAsVectorLayer(parameters, self.IN_VEHICLE_LAYER, context)
        vehicle_start_bool = self.parameterAsBool(parameters, self.IN_VEHICLE_START_BOOL, context)
        vehicle_end_bool = self.parameterAsBool(parameters, self.IN_VEHICLE_END_BOOL, context)
        capacity = self.parameterAsString(parameters, self.IN_VEHICLE_CAPACITY_FIELD, context)
        vehicle_descritption = str(self.parameterAsString(parameters, self.IN_VEHICLE_DESCRIPTION_FIELD, context))
        vehicle_skill = self.parameterAsString(parameters, self.IN_VEHICLE_SKILL_FIELD, context)
        vehicle_time_window = self.parameterAsString(parameters, self.IN_VEHICLE_TIME_WINDOW, context)
        speed_factor = self.parameterAsString(parameters, self.IN_VEHICLE_SPEED_FACTOR_FIELD, context)
        max_tasks = self.parameterAsString(parameters, self.IN_VEHICLE_MAX_TASKS_FIELD, context)
        max_travel_time = self.parameterAsString(parameters, self.IN_VEHICLE_MAX_TRAVEL_TIME, context)
        max_distance = self.parameterAsString(parameters, self.IN_VEHICLE_MAX_DISTANCE, context)

        break_field = self.parameterAsString(parameters, self.IN_BREAK, context)

        pickup_layer = self.parameterAsVectorLayer(parameters, self.IN_PICKUP_LAYER, context)
        start_id = self.parameterAsString(parameters, self.IN_START_FIELD, context)
        amount = self.parameterAsString(parameters, self.IN_AMOUNT_FIELD, context)
        skill = self.parameterAsString(parameters, self.IN_SKILL_FIELD, context)
        priority = self.parameterAsString(parameters, self.IN_PRIORITY_FIELD, context)
        pickup_description = self.parameterAsString(parameters, self.IN_PICKUP_DESCRIPTION, context)
        pickup_setup = self.parameterAsString(parameters, self.IN_PICKUP_SETUP_DURATION_FIELD, context)
        pickup_service = self.parameterAsString(parameters, self.IN_PICKUP_SERVICE_DURATION_FIELD, context)
        pickup_time_windows = self.parameterAsString(parameters, self.IN_PICKUP_TIME_WINDOWS, context)

        delivery_layer = self.parameterAsVectorLayer(parameters, self.IN_DELIVERY_LAYER, context)
        end_id = self.parameterAsString(parameters, self.IN_END_FIELD, context)
        delivery_description = self.parameterAsString(parameters, self.IN_DELIVERY_DESCRIPTION, context)
        delivery_setup = self.parameterAsString(parameters, self.IN_DELIVERY_SETUP_DURATION_FIELD, context)
        delivery_service = self.parameterAsString(parameters, self.IN_DELIVERY_SERVICE_DURATION_FIELD, context)
        delivery_time_windows = self.parameterAsString(parameters, self.IN_DELIVERY_TIME_WINDOWS, context)

        feedback.setProgressText('Input layers loaded')

        # Construction of three output layers:
        ## Line layer for routes

        fields = QgsFields()
        fields.append(QgsField('vehicle', QVariant.Int))
        fields.append(QgsField('description', QVariant.String))
        fields.append(QgsField('cost', QVariant.Int))
        fields.append(QgsField('delivery', QVariant.String))
        fields.append(QgsField('amount', QVariant.String))
        fields.append(QgsField('pickup', QVariant.String))
        fields.append(QgsField('setup', QVariant.Int))
        fields.append(QgsField('service', QVariant.Int))
        fields.append(QgsField('duration', QVariant.Int))
        fields.append(QgsField('waiting_time', QVariant.Int))
        fields.append(QgsField('priority', QVariant.Int))
        fields.append(QgsField('distance', QVariant.Int))
        fields.append(QgsField('nr_of_steps', QVariant.Int))
        fields.append(QgsField('violations', QVariant.String))
        
        (sink, dest_id) = self.parameterAsSink(parameters, self.OUT_LINES,
                context, fields, QgsWkbTypes.LineString, QgsCoordinateReferenceSystem("EPSG:4326"))
        
        ## Point layer for steps

        fields_2 = QgsFields()
        fields_2.append(QgsField('vehicle', QVariant.Int))
        fields_2.append(QgsField('type', QVariant.String))
        fields_2.append(QgsField('description', QVariant.String))
        fields_2.append(QgsField('id', QVariant.Int))
        fields_2.append(QgsField('setup', QVariant.Int))
        fields_2.append(QgsField('service', QVariant.Int))
        fields_2.append(QgsField('waiting_time', QVariant.Int))
        fields_2.append(QgsField('load', QVariant.String))
        fields_2.append(QgsField('arrival_s', QVariant.Int))
        fields_2.append(QgsField('arrival_t', QVariant.DateTime))
        fields_2.append(QgsField('duration', QVariant.Int))
        fields_2.append(QgsField('violations', QVariant.String))
        fields_2.append(QgsField('distance', QVariant.Int))

        (sink_2, dest_id_2) = self.parameterAsSink(parameters, self.OUT_POINTS,
                context, fields_2, QgsWkbTypes.Point, QgsCoordinateReferenceSystem("EPSG:4326"))
        
        ## Summary layer
        
        fields_3 = QgsFields()
        fields_3.append(QgsField('routes', QVariant.Int))
        fields_3.append(QgsField('unassigned', QVariant.Int))
        fields_3.append(QgsField('delivery', QVariant.String))
        fields_3.append(QgsField('amount', QVariant.String))
        fields_3.append(QgsField('pickup', QVariant.String))
        fields_3.append(QgsField('setup', QVariant.Int))
        fields_3.append(QgsField('service', QVariant.Int))
        fields_3.append(QgsField('duration', QVariant.Int))
        fields_3.append(QgsField('waiting_time', QVariant.Int))
        fields_3.append(QgsField('priority', QVariant.Int))
        fields_3.append(QgsField('distance', QVariant.Int))
        fields_3.append(QgsField('violations', QVariant.String))
        fields_3.append(QgsField('computing_times', QVariant.String))
        
        
        (sink_3, dest_id_3) = self.parameterAsSink(parameters, self.OUT_SUMMARY,
                context, fields_3, QgsWkbTypes.NoGeometry)  


        feedback.setProgressText('Output layers created')


        # Reproject input layers to EPSG 4326
        
        repro_veh = processing.run("native:reprojectlayer", {'INPUT':vehicle_layer,
                'TARGET_CRS':QgsCoordinateReferenceSystem('EPSG:4326'),'OUTPUT':'TEMPORARY_OUTPUT'})

        vehicle_layer = repro_veh['OUTPUT']

        repro_pickup = processing.run("native:reprojectlayer", {'INPUT':pickup_layer,
                'TARGET_CRS':QgsCoordinateReferenceSystem('EPSG:4326'),'OUTPUT':'TEMPORARY_OUTPUT'})

        pickup_layer = repro_pickup['OUTPUT']

        repro_deliver = processing.run("native:reprojectlayer", {'INPUT':delivery_layer,
                'TARGET_CRS':QgsCoordinateReferenceSystem('EPSG:4326'),'OUTPUT':'TEMPORARY_OUTPUT'})

        delivery_layer = repro_deliver['OUTPUT']

        feedback.setProgressText('Input layer reprojected to EPSG:4326')

        # Get the text of ORS travel mode from input

        PREFERENCES = ['driving-car',
                       'driving-hgv',
                       "cycling-regular",
                       "cycling-road",
                       "cycling-safe",
                       "cycling-mountain",
                       "cycling-electric",
                       "foot-walking",
                       "foot-hiking",
                       "wheelchair"]

        ors_preference = PREFERENCES[int(ors_preference_nr)]

        # Make the vehicles list for VROOM
        
        vehicles = []
        for count, v in enumerate(vehicle_layer.getFeatures(), start=1):
            g = v.geometry()
            x = g.asPoint().x()
            y = g.asPoint().y()
            coord = [x, y]
            cur_vehicle = {'id':count}
            
            if ors_bool == True or ors_ext == True:
                cur_vehicle['profile'] = ors_preference
            if vehicle_start_bool == True:
                cur_vehicle['start'] = coord
            if vehicle_end_bool == True:
                cur_vehicle['end'] = coord
            if capacity != '':
                cur_vehicle['capacity'] = eval(v[capacity])
            if vehicle_descritption != '':
                cur_vehicle['description'] = str(v[vehicle_descritption])
            if vehicle_skill != '':
                cur_vehicle['skills'] = eval(v[vehicle_skill])
            if vehicle_time_window != '':
                cur_vehicle['time_window'] = eval(v[vehicle_time_window])
            if speed_factor != '':
                cur_vehicle['speed_factor'] = v[speed_factor]
            if max_tasks != '':
                cur_vehicle['max_tasks'] = v[max_tasks]
            if max_distance != '':
                cur_vehicle['max_distance'] = v[max_distance]
            if max_travel_time != '':
                cur_vehicle['max_travel_time'] = v[max_travel_time]
            if break_field != '':
                cur_vehicle['breaks'] = eval(v[break_field])

            vehicles.append(cur_vehicle)
        
        feedback.setProgressText('Vehicle list made')
        
        # Make the shipments list for VROOM

        shipments = []

        not_missing_pickup = []
        
        for count, p in enumerate(pickup_layer.getFeatures(), start=1):
            cur_count = count
            p_g = p.geometry()
            p_x = p_g.asPoint().x()
            p_y = p_g.asPoint().y()
            p_coord = [p_x, p_y]
            cur_pickup = {'id':cur_count,'location':p_coord}

            if pickup_description != '':
                cur_pickup['description'] = str(p[pickup_description])
            if pickup_setup != '':
                cur_pickup['setup'] = p[pickup_setup]
            if pickup_service != '':
                cur_pickup['service'] = p[pickup_service]
            if pickup_time_windows != '':
                cur_pickup['time_windows'] =eval(p[pickup_time_windows])
            
            sort_id = p[start_id]
            missing_delivery = True
            for d in delivery_layer.getFeatures():
                if d[end_id] == sort_id:
                    missing_delivery = False
                    not_missing_pickup.append(d[end_id])
                    d_g = d.geometry()
                    d_x = d_g.asPoint().x()
                    d_y = d_g.asPoint().y()
                    d_coord = [d_x, d_y]
                    cur_delivery = {'id':cur_count,'location':d_coord}

                    if delivery_description != '':
                        cur_delivery['description'] = str(d[delivery_description])
                    if delivery_setup != '':
                        cur_delivery['setup'] = d[delivery_setup]
                    if delivery_service != '':
                        cur_delivery['service'] = d[delivery_service]
                    if delivery_time_windows != '':
                        cur_delivery['time_windows'] = eval(d[delivery_time_windows])
                    
                    cur_shipment = {'pickup':cur_pickup,'delivery':cur_delivery}
                    if amount != '':
                        cur_shipment['amount'] = eval(p[amount])
                    else:
                        cur_shipment['amount'] = [1]
                    if skill != '':
                        cur_shipment['skills'] =eval(p[skill])
                    shipments.append(cur_shipment)
                    if priority != '':
                        cur_shipment['priority'] = p[priority]
            if missing_delivery == True:
                feedback.reportError('Pickup no. '+str(sort_id)+' has no delivery partner!')

        for d in delivery_layer.getFeatures():
            if d[end_id] not in not_missing_pickup:
                feedback.reportError('Delivery no. '+str(d[end_id])+' has no pickup partner!')
        
        feedback.setProgressText('Pickup and Delivery list made')

        # Finalise the JSON fpr VROOM

        vrp = {'vehicles':vehicles,'shipments':shipments,'options':{'g':True}}

        feedback.setProgressText('Finalised JSON of the VRP, ready to be sent to Vroom Express')

        # Sending data to Vroom Express

        body = vrp
        if ors_ext == True:
            headers = {
            'Accept': 'application/json, application/geo+json, application/gpx+xml, img/png; charset=utf-8',
            'Authorization': key,
            'Content-Type': 'application/json; charset=utf-8'
            }
            call = requests.post('https://api.openrouteservice.org/optimization', json=body, headers=headers)
        else:
            call = requests.post('http://localhost:'+port+'/', json=body)
            
        feedback.setProgressText('Vehicle and shipment data sent to Vroom Express.' +'\n')
                 
        # Status code and errors
        
        status_code = call.status_code
        reason = call.reason
        text = call.text

        feedback.pushInfo('Vroom Status Code:' + str(status_code) + ', Reason: ' + str(reason))
        if status_code !=  200:
            raise QgsProcessingException(text)

        # Summary and list of unassigned tasks are written to feedback for short overview 

        opti_result = call.json()
  
        feedback.pushInfo('Summary: ' + str(opti_result['summary']) +'\n')
        feedback.pushInfo('Unassigned: ' + str(opti_result['unassigned']) +'\n')

        # Write the output into the output layers
        
        routes = opti_result['routes']
        for r in routes:
            route_geom = r['geometry']
            
            # decode geometry
            
            length = len(route_geom)
            index = 0
            latitude = 0
            longitude = 0
            decode_geom = []

            while index < length:
                shift = 0
                result_num = 0

                while True:
                    b = ord(route_geom[index]) - 63
                    index += 1
                    result_num |= (b & 0x1F) << shift
                    shift += 5
                    if not b >= 0x20:
                        break

                dlat = ~(result_num >> 1) if result_num & 1 else result_num >> 1
                latitude += dlat

                shift = 0
                result_num = 0

                while True:
                    b = ord(route_geom[index]) - 63
                    index += 1
                    result_num |= (b & 0x1F) << shift
                    shift += 5
                    if not b >= 0x20:
                        break

                dlon = ~(result_num >> 1) if result_num & 1 else result_num >> 1
                longitude += dlon

                decode_geom.append((latitude * 1e-5, longitude * 1e-5))
            
            #decode_geom = polyline.decode(route_geom)
            
            PointList = []
            for t in decode_geom:
                Point = QgsPoint(t[1],t[0])
                PointList.append(Point)
            feature = QgsFeature()
            qgis_geom = QgsGeometry.fromPolyline(PointList)
            feature.setGeometry(qgis_geom)
            vehicle = r['vehicle']
            description = r['description'] if 'description' in r else None
            cost = r['cost']
            delivery = str(r['delivery'])
            amount = str(r['amount'])
            pickup = str(r['pickup'])
            setup = r['setup']
            service = r['service']
            duration = r['duration']
            waiting_time = r['waiting_time']
            distance = r['distance']
            priority = r['priority'] if 'priority' in r else None
            nr_of_steps = len(r['steps'])
            violations = str(r['violations']) if 'violations' in r else None
            
            feature.setAttributes([vehicle, description, cost, delivery, amount, pickup, setup, service, duration,
                                   waiting_time, priority, distance, nr_of_steps, violations])
            sink.addFeature(feature)

            # Provide breaks with coordinates
            
            steps = r['steps']
            
            for s in steps:
                if s['type'] == 'start':
                    start_location = s['location']
                if 'location' not in s:
                    break_duration = s['duration']
                    for st in steps:
                        if 'location' in st and st['duration'] == break_duration:
                            break_location = st['location']
                            s['location'] = break_location
                            break
                if 'location' not in s:
                    s['location'] = start_location
            
            # Point layer
            
            for s in steps:
                s_feature = QgsFeature()
                s_location = s['location']
                s_point = QgsPointXY(s_location[0],s_location[1])
                s_geom = QgsGeometry.fromPointXY(s_point)
                s_feature.setGeometry(s_geom)
                s_type = s['type']
                s_description = s['description'] if 'description' in s else None
                s_id = s['id'] if 'id' in s else None
                s_setup = s['setup'] if  'setup' in s else None
                s_service = s['service'] if 'service' in s else None
                s_waiting_time = s['waiting_time'] if 'waiting_time' in s else None
                s_load = str(s['load'])
                s_arrival_s = s['arrival']
                s_arrival_t = QDateTime.fromSecsSinceEpoch(s['arrival'])
                s_duration = s['duration']
                s_violations = str(s['violations']) if 'violations' in s else None
                s_distance = s['distance']
                s_feature.setAttributes([vehicle, s_type, s_description, s_id, s_setup, s_service, s_waiting_time, s_load,
                                         s_arrival_s, s_arrival_t, s_duration, s_violations, s_distance])
                sink_2.addFeature(s_feature)
                
        # Summary layer
        
        summary = opti_result['summary']
        
        summary_feature = QgsFeature()
        
        summary_routes = summary['routes']
        summary_unassigend = summary['unassigned']
        summary_delivery = str(summary['delivery'])
        summary_amount = str(summary['amount'])
        summary_pickup = str(summary['pickup'])
        summary_setup = summary['setup']
        summary_service = summary['service']
        summary_duration = summary['duration']
        summary_waiting_time = summary['waiting_time']
        summary_priority = summary['priority']
        summary_distance = summary['distance']
        summary_violations = str(summary['violations'])
        summary_computing_times = str(summary['computing_times'])
        
        summary_feature.setAttributes([summary_routes, summary_unassigend, summary_delivery, summary_amount, summary_pickup,
                                       summary_setup, summary_service, summary_duration, summary_waiting_time, summary_priority,
                                       summary_distance, summary_violations, summary_computing_times])
        sink_3.addFeature(summary_feature)
        

        return {self.OUT_LINES: dest_id, self.OUT_POINTS: dest_id_2, self.OUT_SUMMARY: dest_id_3}

    def name(self):
        return 'VROOM for QGIS'

    def displayName(self):
        return self.tr(self.name())

    def group(self):
        return self.tr(self.groupId())

    def groupId(self):
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return VROOM_for_QGISAlgorithm()
